# Функциональное и логическое программирование
##### Курс УрФУ

### Домашние задания
* Prolog
    1. [x] Производные
       <br>__Что надо сделать:__ дописать Лукач-программу, научить её брать производные
    *  [x] Алгоритм Дейкстры
       <br>__Что надо сделать:__ _внезапно_, алгоритм Дейкстры
* Haskell
    1. [x] Трансмутация мухи в слон
        <br> __Что есть:__ словарь слов
        <br>__Что надо сделать:__ научиться превращать, одно слово в другое, на каждом шагу меняя только одну букву
    *  [ ] [Бинарное дерево](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
    *  [x] Очередь
        <br> __Что есть:__ 2 готовые реализации очередей с 5 операциями
        <br>__Что надо сделать:__ еще одна реализация очереди
        <br> __О чем ты вообще?__
        * Очереди
            * [x] `SimpleQueue`
                <br> Простой список, именно то о чем вы подумали
            * [x] `TwoListQueue`
                <br> Сложность push в простом списке O(n), не хорошо
                Поэтому мы будем использовать 2 списка
                Из первого мы всегда берем элементы(pop, top) O(1)
                В начало второго всегда складываем (push) O(1)
                Если при pop список оказался пустой, то делаем реверс второго списка и складываем в первый O(n)
            * [ ] `TwoListQueue` с баллансировкой
                <br> Но и это не идеально, у нас может случится ситуация при которой мы много складываем и мало берем, тогда в один прекрасный момент нам придется разворачивать огромный список, что очень дорого
                Вариант решения: держать второй список короче первого
                Проблема: стандартный length работает дольше чем O(1)
                Поэтому нужно прикрутить к `TwoListQueue` 2 переменные в которой храним длины списков
                меняя их при операциях pop, push O(1), а так-же делать ряд проверок
                При pop: если первый список оказался меньше второго, перевернуть второй и прифигачить к хвосту
                При push, если второй список оказался больше, развернуть и прифигачить к первому
        * Операции
            * `pop` - возвращает очередь без первого элемента
            * `top` - возвращает первый элемент очереди
            * `push` - добавляет элемент в конец очереди
            * `create` - конструктор очереди
            * `empty` - проверка на пустоту
        <br>
